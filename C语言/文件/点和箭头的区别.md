## 1. **基本区别**

|运算符|使用场景|示例|
|---|---|---|
|**`.`**|直接访问**结构体变量**的成员|`student.age`|
|**`->`**|通过**结构体指针**访问成员|`pStudent->age`|

## 2. **详细对比**

### 示例结构体定义：


`typedef struct {`
    `char name[20];`
    `int age;`
    `float score;`
`} Student;`

### 情况1：使用结构体变量（`.`）


`// 创建结构体变量`
`Student student1;`

`// 使用点运算符访问成员`
`student1.age = 20;`
`strcpy(student1.name, "张三");`
`student1.score = 85.5;`

`// 也可以这样初始化`
`Student student2 = {"李四", 22, 90.5};`

### 情况2：使用结构体指针（`->`）


`// 创建结构体变量`
`Student student1 = {"王五", 21, 88.0};`

`// 创建指向结构体的指针`
`Student *pStudent;`

`// 让指针指向结构体变量`
`pStudent = &student1;`

`// 使用箭头运算符访问成员`
`pStudent->age = 23;      // 等价于 (*pStudent).age`
`strcpy(pStudent->name, "赵六");`
`pStudent->score = 92.5;`

`// 也可以动态分配内存`
`Student *pDynamic = (Student*)malloc(sizeof(Student));`
`pDynamic->age = 25;`
`strcpy(pDynamic->name, "钱七");`
`pDynamic->score = 95.0;`
`free(pDynamic);`

## 3. **等价关系**


`// 以下三种写法是等价的：`
`Student stu;`
`Student *p = &stu;`

`stu.age = 20;       // 直接访问`
`(*p).age = 20;      // 先解引用，再用点运算符`
`p->age = 20;        // 箭头运算符（最常用）`

`// 证明：`
`printf("stu.age = %d\n", stu.age);     // 20`
`printf("(*p).age = %d\n", (*p).age);   // 20`  
`printf("p->age = %d\n", p->age);       // 20`

## 4. **实际使用场景**

### 场景1：函数参数传递

`// 传递结构体变量（值传递）`
`void printStudent(Student stu) {`
    `printf("姓名: %s\n", stu.name);    // 使用 .`
    `printf("年龄: %d\n", stu.age);`
`}`

`// 传递结构体指针（地址传递，效率更高）`
`void printStudentByPtr(const Student *pStu) {`
    `printf("姓名: %s\n", pStu->name);  // 使用 ->`
    `printf("年龄: %d\n", pStu->age);`
`}`

`int main() {`
    `Student stu = {"张三", 20, 85.5};`
    
    `printStudent(stu);         // 传值，使用 .`
    `printStudentByPtr(&stu);   // 传指针，使用 ->`
    
    `return 0;`
`}`

### 场景2：动态结构体数组

`typedef struct {`
    `int id;`
    `char name[50];`
`} Employee;`

`int main() {`
    `// 动态创建结构体数组`
    `Employee *employees = (Employee*)malloc(3 * sizeof(Employee));`
    
    `// 使用箭头运算符访问`
    `employees[0].id = 1;           // 数组元素是结构体，用 .`
    `strcpy(employees[0].name, "张三");`
    
    `(employees + 1)->id = 2;       // 指针运算，用 ->`
    `strcpy((employees + 1)->name, "李四");`
    
    `// 另一种写法`
    `Employee *ptr = employees + 2;`
    `ptr->id = 3;                   // 指针，用 ->`
    `strcpy(ptr->name, "王五");`
    
    `free(employees);`
    `return 0;`
`}`

### 场景3：嵌套结构体

`typedef struct {`
    `int year;`
    `int month;`
    `int day;`
`} Date;`

`typedef struct {`
    `char name[20];`
    `Date birthday;      // 嵌套结构体`
    `Date *pDate;        // 指向Date的指针`
`} Person;`

`int main() {`
    `Person person;`
    `Date date = {2000, 5, 20};`
    
    `// 访问嵌套结构体`
    `person.birthday.year = 2000;    // 使用 .`
    
    `// 通过指针访问`
    `person.pDate = &date;`
    `person.pDate->year = 2001;      // 使用 ->`
    
    `// 混合使用`
    `Person *pPerson = &person;`
    `pPerson->birthday.month = 5;    // -> 然后 .`
    
    `return 0;`
`}`

## 5. **常见错误**

`// ❌ 错误示例1：混淆使用`
`Student *p = &student1;`
`p.age = 20;        // 错误！p是指针，应该用->或先解引用`
`(*p).age = 20;     // 正确`
`p->age = 20;       // 正确`

`// ❌ 错误示例2：优先级问题`
`int *p;`
`*p->age;           // 错误：->优先级高于*`
`(*p)->age;         // 正确：先解引用p`

`// ❌ 错误示例3：未初始化指针`
`Student *p;`
`p->age = 20;       // 错误：p未指向有效的内存区域`

`// ✅ 正确做法`
`Student *p = (Student*)malloc(sizeof(Student));`
`p->age = 20;       // 正确：p已指向有效内存`

## 6. **记忆技巧**

1. **左边是变量用`.`**：`变量.成员`
    
2. **左边是指针用`->`**：`指针->成员`
    
3. **可以相互转换**：`p->age` 等价于 `(*p).age`
    
4. **`->`更简洁**：是`(* ).`的简写形式
    

## 7. **在链表中常见用法**

`typedef struct Node {`
    `int data;`
    `struct Node *next;  // 指向下一个节点的指针`
`} Node;`

`int main() {`
    `Node *head = (Node*)malloc(sizeof(Node));`
    `head->data = 1;                    // 访问当前节点的data`
    `head->next = (Node*)malloc(sizeof(Node));  // 访问next指针`
    `head->next->data = 2;              // 访问下一个节点的data`
    
    `// 遍历链表`
    `Node *current = head;`
    `while (current != NULL) {`
        `printf("%d ", current->data);  // 必须用->`
        `current = current->next;       // 移动到下一个节点`
    `}`
    
    `return 0;`
`}`

## 总结：

- **`.`** 用于结构体/共用体**变量**
    
- **`->`** 用于结构体/共用体**指针**
    
- `p->member` 等价于 `(*p).member`
    
- 选择哪个运算符取决于你拥有的是**变量**还是**指针**
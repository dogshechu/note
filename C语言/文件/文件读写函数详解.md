### 1. 字符级读写

#### fgetc() 和 getc()

c

`int fgetc(FILE *stream);`
`int getc(FILE *stream);  // 通常是宏，更快`

- 读取一个字符
    
- 返回类型是int，不是char（为了能表示EOF）
    
- EOF通常在stdio.h中定义为-1
    

#### fputc() 和 putc()

c

`int fputc(int c, FILE *stream);`
`int putc(int c, FILE *stream);  // 通常是宏`

- 写入一个字符
    
- 参数c被转换为unsigned char
    

**字符复制文件示例：**

c
 
```c
#include <stdio.h>
 void copy_file_char_by_char(const char *src, const char *dest) {
 FILE *in = fopen(src, "r");
   FILE *out = fopen(dest, "w");
   int ch;
  if (in == NULL || out == NULL) {
  perror("文件打开失败");
   return;
        }
while ((ch = fgetc(in)) != EOF) {
  fputc(ch, out);
             }
          fclose(in);
          fclose(out);
           }
```
    
### 2. 字符串级读写

#### fgets() - 读取字符串

c

`char *fgets(char *str, int n, FILE *stream);`

- 读取最多n-1个字符
    
- 遇到换行符或文件结束停止
    
- 保留换行符并添加'\0'
    
- 比gets()安全（gets()已被废弃）
    

#### fputs() - 写入字符串

c

`int fputs(const char *str, FILE *stream);`

- 写入字符串，不添加换行符
    
- 需要手动添加'\n'来换行
    

**行复制文件示例：**

c
```c

#include <stdio.h>
#include <string.h>
void copy_file_line_by_line(const char *src, const char *dest) {
    FILE *in = fopen(src, "r");
    FILE *out = fopen(dest, "w");
    char buffer[1024];
if (in == NULL || out == NULL) {
        perror("文件打开失败");
        return;
    }
while (fgets(buffer, sizeof(buffer), in) != NULL) {
        // 移除可能的换行符（可选）
        buffer[strcspn(buffer, "\n")] = '\0';
        // 添加自定义格式
        fprintf(out, "行内容: %s\n", buffer);
}fclose(in);
    fclose(out);
}
```
``
### 3. 格式化读写

#### fprintf() - 格式化写入

c

`int fprintf(FILE *stream, const char *format, ...);`

- 类似于printf，但输出到文件
    
- 返回成功写入的字符数
    
`fprintf(fp, "%d %10.6f %10.6f", i, sin(i), cos(i));`
#### fscanf() - 格式化读取

c

`int fscanf(FILE *stream, const char *format, ...);`

- 类似于scanf，但从文件读取
    
- 返回成功匹配并赋值的输入项数
    失败返回EOF(通常是-1)

**配置文件读写示例：**

`c`
```c

#include <stdio.h>
typedef struct {
    char name[50];
    int age;
    float salary;
} Employee;
void write_config() {
    FILE *fp = fopen("config.txt", "w");
    if (!fp) return;
    fprintf(fp, "# 员工配置文件\n");
    fprintf(fp, "name=张三\n");
    fprintf(fp, "age=30\n");
    fprintf(fp, "salary=5000.50\n");
    fclose(fp);
}
void read_employee_data() {
    Employee emp;
    FILE *fp = fopen("employee.dat", "r");
    if (!fp) return;
    // 方式1：直接读取
    fscanf(fp, "%s %d %f", emp.name, &emp.age, &emp.salary);
    // 方式2：带格式读取
    fscanf(fp, "姓名: %s, 年龄: %d, 工资: %f",
           emp.name, &emp.age, &emp.salary);
    fclose(fp);
}
```
``
### 4. 二进制读写

#### fread() - 二进制读取

c

`size_t fread(void *ptr, size_t size, size_t count, FILE *stream);`

- 读取count个大小为size的数据块
    
- 返回成功读取的完整数据块数量
    

#### fwrite() - 二进制写入

c

`size_t fwrite(const void *ptr, size_t size, size_t count, FILE *stream);`

- 写入count个大小为size的数据块
    
- 返回成功写入的完整数据块数量
    

**结构体数组文件操作示例：**

c

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_STUDENTS 100

typedef struct {
    int id;
    char name[50];
    float scores[3];
} Student;

void save_students(Student students[], int count) {
    FILE *fp = fopen("students.dat", "wb");
    if (!fp) return;
    
    // 写入记录数量
    fwrite(&count, sizeof(int), 1, fp);
    
    // 写入所有学生数据
    fwrite(students, sizeof(Student), count, fp);
    
    fclose(fp);
}

int load_students(Student students[]) {
    FILE *fp = fopen("students.dat", "rb");
    if (!fp) return 0;
    
    int count;
    // 读取记录数量
    fread(&count, sizeof(int), 1, fp);
    
    // 读取学生数据
    fread(students, sizeof(Student), count, fp);
    
    fclose(fp);
    return count;
}```